/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 5.26.1
 * source: api/common/c_base.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as dependency_1 from "./../../validate/validate";
import * as pb_1 from "google-protobuf";
export namespace api.common {
    export enum DisableStatus {
        DEFAULT = 0,
        ENABLE = 1,
        DISABLE = 2
    }
    export enum PageUpDown {
        PUD_DEFAULT = 0,
        PUD_UP = 1,
        PUD_DOWN = 2
    }
    export class BaseResponse extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {}) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") { }
        }
        static fromObject(data: {}): BaseResponse {
            const message = new BaseResponse({});
            return message;
        }
        toObject() {
            const data: {} = {};
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): BaseResponse {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new BaseResponse();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): BaseResponse {
            return BaseResponse.deserialize(bytes);
        }
    }
    export class Page extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            page?: number;
            limit?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("page" in data && data.page != undefined) {
                    this.page = data.page;
                }
                if ("limit" in data && data.limit != undefined) {
                    this.limit = data.limit;
                }
            }
        }
        get page() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set page(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get limit() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set limit(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            page?: number;
            limit?: number;
        }): Page {
            const message = new Page({});
            if (data.page != null) {
                message.page = data.page;
            }
            if (data.limit != null) {
                message.limit = data.limit;
            }
            return message;
        }
        toObject() {
            const data: {
                page?: number;
                limit?: number;
            } = {};
            if (this.page != null) {
                data.page = this.page;
            }
            if (this.limit != null) {
                data.limit = this.limit;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.page != 0)
                writer.writeInt32(1, this.page);
            if (this.limit != 0)
                writer.writeInt32(2, this.limit);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Page {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Page();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.page = reader.readInt32();
                        break;
                    case 2:
                        message.limit = reader.readInt32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Page {
            return Page.deserialize(bytes);
        }
    }
    export class Batch extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            offset?: number;
            limit?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("offset" in data && data.offset != undefined) {
                    this.offset = data.offset;
                }
                if ("limit" in data && data.limit != undefined) {
                    this.limit = data.limit;
                }
            }
        }
        get offset() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set offset(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get limit() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set limit(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            offset?: number;
            limit?: number;
        }): Batch {
            const message = new Batch({});
            if (data.offset != null) {
                message.offset = data.offset;
            }
            if (data.limit != null) {
                message.limit = data.limit;
            }
            return message;
        }
        toObject() {
            const data: {
                offset?: number;
                limit?: number;
            } = {};
            if (this.offset != null) {
                data.offset = this.offset;
            }
            if (this.limit != null) {
                data.limit = this.limit;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.offset != 0)
                writer.writeInt32(1, this.offset);
            if (this.limit != 0)
                writer.writeInt32(2, this.limit);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Batch {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Batch();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.offset = reader.readInt32();
                        break;
                    case 2:
                        message.limit = reader.readInt32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Batch {
            return Batch.deserialize(bytes);
        }
    }
    export class ListInt32 extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            i32?: number[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("i32" in data && data.i32 != undefined) {
                    this.i32 = data.i32;
                }
            }
        }
        get i32() {
            return pb_1.Message.getFieldWithDefault(this, 1, []) as number[];
        }
        set i32(value: number[]) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            i32?: number[];
        }): ListInt32 {
            const message = new ListInt32({});
            if (data.i32 != null) {
                message.i32 = data.i32;
            }
            return message;
        }
        toObject() {
            const data: {
                i32?: number[];
            } = {};
            if (this.i32 != null) {
                data.i32 = this.i32;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.i32.length)
                writer.writePackedInt32(1, this.i32);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ListInt32 {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ListInt32();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.i32 = reader.readPackedInt32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ListInt32 {
            return ListInt32.deserialize(bytes);
        }
    }
    export class ListInt64 extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            i64?: number[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("i64" in data && data.i64 != undefined) {
                    this.i64 = data.i64;
                }
            }
        }
        get i64() {
            return pb_1.Message.getFieldWithDefault(this, 1, []) as number[];
        }
        set i64(value: number[]) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            i64?: number[];
        }): ListInt64 {
            const message = new ListInt64({});
            if (data.i64 != null) {
                message.i64 = data.i64;
            }
            return message;
        }
        toObject() {
            const data: {
                i64?: number[];
            } = {};
            if (this.i64 != null) {
                data.i64 = this.i64;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.i64.length)
                writer.writePackedInt64(1, this.i64);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ListInt64 {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ListInt64();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.i64 = reader.readPackedInt64();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ListInt64 {
            return ListInt64.deserialize(bytes);
        }
    }
    export class ListFloat32 extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            f32?: number[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("f32" in data && data.f32 != undefined) {
                    this.f32 = data.f32;
                }
            }
        }
        get f32() {
            return pb_1.Message.getFieldWithDefault(this, 1, []) as number[];
        }
        set f32(value: number[]) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            f32?: number[];
        }): ListFloat32 {
            const message = new ListFloat32({});
            if (data.f32 != null) {
                message.f32 = data.f32;
            }
            return message;
        }
        toObject() {
            const data: {
                f32?: number[];
            } = {};
            if (this.f32 != null) {
                data.f32 = this.f32;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.f32.length)
                writer.writePackedFloat(1, this.f32);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ListFloat32 {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ListFloat32();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.f32 = reader.readPackedFloat();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ListFloat32 {
            return ListFloat32.deserialize(bytes);
        }
    }
    export class ListFloat64 extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            f64?: number[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("f64" in data && data.f64 != undefined) {
                    this.f64 = data.f64;
                }
            }
        }
        get f64() {
            return pb_1.Message.getFieldWithDefault(this, 1, []) as number[];
        }
        set f64(value: number[]) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            f64?: number[];
        }): ListFloat64 {
            const message = new ListFloat64({});
            if (data.f64 != null) {
                message.f64 = data.f64;
            }
            return message;
        }
        toObject() {
            const data: {
                f64?: number[];
            } = {};
            if (this.f64 != null) {
                data.f64 = this.f64;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.f64.length)
                writer.writePackedDouble(1, this.f64);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ListFloat64 {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ListFloat64();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.f64 = reader.readPackedDouble();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ListFloat64 {
            return ListFloat64.deserialize(bytes);
        }
    }
    export class ListString extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            str?: string[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("str" in data && data.str != undefined) {
                    this.str = data.str;
                }
            }
        }
        get str() {
            return pb_1.Message.getFieldWithDefault(this, 1, []) as string[];
        }
        set str(value: string[]) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            str?: string[];
        }): ListString {
            const message = new ListString({});
            if (data.str != null) {
                message.str = data.str;
            }
            return message;
        }
        toObject() {
            const data: {
                str?: string[];
            } = {};
            if (this.str != null) {
                data.str = this.str;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.str.length)
                writer.writeRepeatedString(1, this.str);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ListString {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ListString();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        pb_1.Message.addToRepeatedField(message, 1, reader.readString());
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ListString {
            return ListString.deserialize(bytes);
        }
    }
    export class SetInt32 extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            i32?: Map<number, number>;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("i32" in data && data.i32 != undefined) {
                    this.i32 = data.i32;
                }
            }
            if (!this.i32)
                this.i32 = new Map();
        }
        get i32() {
            return pb_1.Message.getField(this, 1) as any as Map<number, number>;
        }
        set i32(value: Map<number, number>) {
            pb_1.Message.setField(this, 1, value as any);
        }
        static fromObject(data: {
            i32?: {
                [key: number]: number;
            };
        }): SetInt32 {
            const message = new SetInt32({});
            if (typeof data.i32 == "object") {
                message.i32 = new Map(Object.entries(data.i32).map(([key, value]) => [Number(key), value]));
            }
            return message;
        }
        toObject() {
            const data: {
                i32?: {
                    [key: number]: number;
                };
            } = {};
            if (this.i32 != null) {
                data.i32 = (Object.fromEntries)(this.i32);
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            for (const [key, value] of this.i32) {
                writer.writeMessage(1, this.i32, () => {
                    writer.writeInt32(1, key);
                    writer.writeInt64(2, value);
                });
            }
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SetInt32 {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SetInt32();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.i32 as any, reader, reader.readInt32, reader.readInt64));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SetInt32 {
            return SetInt32.deserialize(bytes);
        }
    }
    export class SetInt64 extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            i64?: Map<number, number>;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("i64" in data && data.i64 != undefined) {
                    this.i64 = data.i64;
                }
            }
            if (!this.i64)
                this.i64 = new Map();
        }
        get i64() {
            return pb_1.Message.getField(this, 1) as any as Map<number, number>;
        }
        set i64(value: Map<number, number>) {
            pb_1.Message.setField(this, 1, value as any);
        }
        static fromObject(data: {
            i64?: {
                [key: number]: number;
            };
        }): SetInt64 {
            const message = new SetInt64({});
            if (typeof data.i64 == "object") {
                message.i64 = new Map(Object.entries(data.i64).map(([key, value]) => [Number(key), value]));
            }
            return message;
        }
        toObject() {
            const data: {
                i64?: {
                    [key: number]: number;
                };
            } = {};
            if (this.i64 != null) {
                data.i64 = (Object.fromEntries)(this.i64);
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            for (const [key, value] of this.i64) {
                writer.writeMessage(1, this.i64, () => {
                    writer.writeInt64(1, key);
                    writer.writeInt64(2, value);
                });
            }
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SetInt64 {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SetInt64();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.i64 as any, reader, reader.readInt64, reader.readInt64));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SetInt64 {
            return SetInt64.deserialize(bytes);
        }
    }
    export class SetString extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            str?: Map<string, number>;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("str" in data && data.str != undefined) {
                    this.str = data.str;
                }
            }
            if (!this.str)
                this.str = new Map();
        }
        get str() {
            return pb_1.Message.getField(this, 1) as any as Map<string, number>;
        }
        set str(value: Map<string, number>) {
            pb_1.Message.setField(this, 1, value as any);
        }
        static fromObject(data: {
            str?: {
                [key: string]: number;
            };
        }): SetString {
            const message = new SetString({});
            if (typeof data.str == "object") {
                message.str = new Map(Object.entries(data.str));
            }
            return message;
        }
        toObject() {
            const data: {
                str?: {
                    [key: string]: number;
                };
            } = {};
            if (this.str != null) {
                data.str = (Object.fromEntries)(this.str);
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            for (const [key, value] of this.str) {
                writer.writeMessage(1, this.str, () => {
                    writer.writeString(1, key);
                    writer.writeInt64(2, value);
                });
            }
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SetString {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SetString();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.str as any, reader, reader.readString, reader.readInt64));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SetString {
            return SetString.deserialize(bytes);
        }
    }
}
